这种区间dp题型没有怎么做过・・・
(竟然有空字符串，无聊，导致一次WA・・・)
其实以前就是不知道区间dp的名字而已，就是一般的dp嘛，没什么特别的・・・

太sb了，scanf("%d\n")错了，改为getchar()就对了・・・

上网查了一下，看到一个类似的问题：石子归并问题！

很类似，思路如下：

描述： 有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

分析：要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。
定义状态dp [ i ] [ j ]为从第i个石子到第j个石子的合并最小代价。
那么dp [ i ] [ j ] = min(dp [ i ] [ k ] + dp [ k+1 ] [ j ]) 
那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。
这个问题可以用到平行四边形优化，用一个s【i】【j】=k 表示区间 i---j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2）.


(平行四边形优化这个名字看起来好高端，其实也没啥・・・就是给了下一次枚举的范围・・・(其实没有这么简单，它之所以叫平行四边形优化是有原因的！见下！)
我有一次做汉诺塔的题就用到了这个思路，自己想到的)

#include <cstdio>  
#include <cstring>  
#include <algorithm>  
#define N 210  
int dp[N][N],sum[N],s[N][N];  
int main()  
{  
    int n;  
    while(~scanf("%d",&n))  
    {  
        int a[N];sum[0]=0;  
        memset(s,0,sizeof(s));  
        for(int i=1;i<=n;i++){  
            scanf("%d",&a[i]);  
            s[i][i]=i;  
            sum[i]=sum[i-1]+a[i];  
        }  
        memset(dp,0,sizeof(dp));  
        int i,j,l,k;  
        for(l = 2; l <= n; ++l)  
        {  
            for(i = 1; i <= n - l + 1; ++i)  
            {  
                j = i + l - 1;  
                dp[i][j] = 2100000000;  
                for(k = s[i][j-1]; k <= s[i+1][j]; ++k)  
                {  
                    if(dp[i][j]>dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1])  
                    {  
                        dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1];  
                        s[i][j]=k;  
                    }  
                }  
            }  
        }  
        printf("%d\n", dp[1][n]);  
    }  
    return 0;  
}  


题目大意很简单，和普通的石子合并过程没有区别，只是花费变成了一个多项式，若连续的任意个石子权值和为x，那么代价变为F(x) = sigma(a[i] * x^i)，求将n堆石子合并为一队的最小花费。

对于暴力的做法，复杂度是O(n^3)的，所以要优化

我们知道当a, b, c, d(a <= b < c <= d)当有cost[a][c] + cost[b][d] <= cost[a][d] + cost[b][c] 时，我们称其满足四边形不等式，设p[i][j]表示当区间[i, j]取最优决策时所选择的下标，
这时可以证明有p[i][j - 1] <= p[i][j] <= p[i + 1][j]。

其实相当好证明啊！！反证法。
（这个证明确实有些naive，这里面的cost[][]实际上是dp[][]。事实上，是w[][]的这个性质可推dp[][]的这个性质，再推出来最后的不等式性质。具体的见ppt.docx。）

1-9时，假设cost[1][5] + cost[6][9]最优。
2-10时，假设cost[2][7] + cost[8][10]最优。
那么若1-10时，cost[1][8] + cost[9][10]最优（此时p[i][j] > p[i+1][j], 我们要推出矛盾）
我们现在有两个不等式：
1-8 + 9-10 < 1-7 + 8-10
2-7 + 8-10 < 2-8 + 9-10
两式相加，得到 1-8 + 2-7 < 1-7 + 2-8, 与条件矛盾。

这时当按区间dp时，计算区间[i, j]的最优解，只要枚举[p[i][j - 1], p[i + 1][j]]即可，由于数组p取值为[1, n]且是单调的，所以枚举的总复杂度为O(n)
（太对了！看上面的代码，就是对应于每个 l ,后两层循环的复杂度一起是O(n)），
最后加上区间枚举的复杂度，总复杂度为O(n^2)

所以对于一般性的题目，需要证明的只有dp量是不是满足四边形不等式的，对于这道题就是要证明:

设sum(a, b) = x, sum(b, c) = z, sum(c, d) = y;

有 F(x + z) + F(y + z) <= F(z) + F(x + y + z),即证明:

sigma(a[i] * ( (x + z)^i + (y + z)^i - z^i - (x+y+z)^i )) <= 0,转化为证明：

(x + z) ^ n  +  (y + z) ^ n  -  z ^ n  -  (x + y + z) ^ n <= 0恒成立。

很明显这个不等式可以利用数学归纳法加以简单的证明。