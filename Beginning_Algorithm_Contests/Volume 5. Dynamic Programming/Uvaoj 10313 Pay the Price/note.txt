这题我想麻烦了・・・

其实用一个二维数组就能搞定，但我用了三维・・・

我的想法就是原来dp的拓展：
凑money这么多钱，用不超过coin个硬币，最大的硬币值c块钱。

所以果然TLE了・・・

有点弱智・・・
这题把memset放在while loop外面啊！！！

一个更好的思路:

用不超过j个硬币凑出面值i的方案种数，是和用面值不超过j的硬币凑出面值i的方案种数是相同的。
说得再数学一点，就是整数i拆分成不超过j个整数的拆分数，是和整数i拆成若干个值不超过j的整数的拆分数是相同的

这样的话我们就可以取一个二维数组f[i][j]表示用面值不超过j的硬币凑出面值i的方案的种数，那么如果我使用了面值j，
对应方案种数就应该加上f[i-j][j]，如果我们不使用面值j，那么对应的方案种数就应该加上f[i][j-1]。也就是说状态转移方程为f[i][j]= f[i-j][j]+ f[i][j-1]。

见pdf


法二：

for (int i = 1 ; i <= 300 ; ++ i)  
    for (int j = 1 ; j <= 300 ; ++ j)  
    for (int k = i ; k <= 300 ; ++ k)  
        F[j][k] += F[j-1][k-i]; 

这个代码是对的，可惜感觉网上大部分解释都没有到点上。
设f（i，j）为j拆分成i个元素的拆法。

关键是在 i 是在最外层的loop！！
实际上 i 控制着这一层，最大的硬币的面值。

其实感觉把我的代码的recursion形式优化一下，优化一维，应该就是这个方法了。

不过还是那个“更好的思路”最好，O(n^2)