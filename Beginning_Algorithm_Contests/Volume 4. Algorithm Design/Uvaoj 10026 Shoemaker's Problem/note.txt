我的算法：类似于冒泡排序。

每次相邻的两个比较，看看需要不需要交换位置。


给出每笔生意需要的天数和每天的罚钱数，求出最小罚钱的排列顺序。

   只要按 罚款/天数 去从大到小排序，如果比例一样就按序号排序（要求字典序）。

   解释我就不献丑了，附上Staginner大神的证明：
对于为什么贪心策略是这个样子的，我们不妨拿相邻的两个事件a、b来说明一下。由于a、b之后的事件是固定的，
所以我们无论排成ab还是排成ba后面部分的损失都是固定的，那么损失的差别主要来源于究竟是排成ab还是排b成a。排
ab的损失为ta*fb，排ba的损失为tb*fa，那么如果ta*fb<tb*fa，我们就排成ab，这样可以得到fa/ta>fb/tb，推而广之，就得到了我们的贪心策略。

其实这题就是一个变种的排序问题。只不过对于struct，重载了一下 < 。

不光用冒泡排序，任何排序应该都可以吧。


如果有多个方案时要字典序输出，考虑到sort函数是不稳定的，感觉会出错，但还是抱着试试的态度提交了，
想着如果WA了就换stable_sort，但是竟然AC了...这个...先不管了，先就这样吧

注意需要稳定排序・・・