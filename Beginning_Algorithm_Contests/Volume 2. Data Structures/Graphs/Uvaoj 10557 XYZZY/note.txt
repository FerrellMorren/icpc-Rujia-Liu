直接写会TLE・・・

所以加了一个预处理，先计算那些房间是能够到最后的房间的。

如果这个房间本身都到不了，就不管它了・・・

能够再加快算法！！

见第二版。

我的改进算法不对，想了半天・・・
终于明白为什么了・・・


if(maxe[nextRoom] > 0){ //其实这个想表达它有一个正环。但是这个不对，因为它并不是充要条件！可能有两条不同的路同向这个房间！
						okay = true;
						break;
					}

还有别的解法：
当发现有个和为正值的环存在时，直接求看该点能否直接到达终点。
(判断是否有正环也很简单，直接dfs一次就行了・・・也算预处理)

如果可以，直接返回true，即winnable。否则，不用做任何的标记。
因为不会再去探索它是否可以直接到达终点。这个方法效率很高。rank:7。
在搜索的过程中看看有没有正环，没有正环则继续搜索，当发现所有路径都不能到达终点时，返回假值。

而且这难道不是一个含负权最短路的题吗・・・
我怎么一开始没看出来・・・

(应该直接套用模板就可以。有负权的情况，直接看d[n]的值应该就可以。但是应该注意跳出循环那个值，使得d[n]至少松弛n-1次或是不再减少)
以上我猜的・・・没有严格证明・・・
松弛次数错的！！！有可能需要好多好多次！！！因为要通过负权刷足够的energy・・・

我的解答基本就是一个比较差的SPFA的实现・・・

含负权单源最短路

用spfa又试了一次，WA・・・
我猜想因为有可能中间某个地方大于了100，然后最后少于100，也算成功了。

终于明白为什么直接的SPFA错了・・・・
尼玛啊！！！又是两个小时没了・・・・
上面关于松弛次数的分析错的！！！有可能需要好多好多次！！！因为要通过负权刷足够的energy・・・

妈的，所以spfa还需要结合有没有通向终点负权路，还不如直接做・・・


