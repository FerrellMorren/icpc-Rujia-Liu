这题太尼玛麻烦了吧！！！

写了一个多小时了・・・

太麻烦了！！！烦死人了！！！还不一定写的对・・・

正式比赛绝对不会写这种题的，实在太恶心了・・・

我实现了好长时间，写了快300行・・・感觉靠谱了・・・

不过忘记看题目要求了，先要求最短，然后才是字典序。
所以不能直接递归，因为这样的只是字典序，而不是最短。

发现了一个特别奇怪的bug：

程序中加入printf("kao\n");就不会有runtime error，而如果没有这个输出语句就会runtime error！

太奇怪了吧・・・

妈的，找了一个小时的bug，最后问题出在这里：
for(int i=0;i<min((int)now.size(),9);i++){

忘记写min了（也没有写（int）now.size），于是变为for(int i=0;i<（now.size(),9);i++){

（now.size(),9)的值莫名其妙，导致频繁出错・・・我是服了・・・

而且这个错误竟然可compile对，我是彻底服了・・・

于是现在变为了WA，我已经快疯掉了・・・

这题太尼玛恶心了，根本没法做・・・还尼玛有陷阱，多了一行，竟然是任意的！未必是换行・・・

WA头疼，上网看了解析・・・我的思路基本是对的，但是coding过程估计有错・・・
明天再看・・・已找到错误数据・・・


我靠，真是崩溃了・・・题目还是没看明白・・・

宝石以相同的速度前进，所以不能直接求出最后的状态！！
可能在行进过程中就会有宝石消失！！！！

太尼玛恶习了吧，这题・・・

我靠，太尼玛恶心了・・・

又把题目意思弄错了・・・

靠靠靠，其实我第一次理解的题意是对的・・・
上一段就是扯淡・・・
但是不知为何WA，反正不是上面那个原因。
让我有上段的错误理解是因为我把网上报告的input和output没有对上号・・
写报告那个人自己确实也没写清楚・・・

我现在已经很接近正确解法了，网上的那20个数据都过了・・・

目前所有数据都过了，但仍然是WA・・・我已经快不行了・・・
这题所有能碰到的问题我应该都经历过了・・・

太好啦！！！！我终于解决问题了！！！！

实在找不到错误数据，于是还是硬看代码找到的bug・・・

竟然是一个笔误，结构体point的 < 运算符写错了・・・
if(a.x == b.x)
	return a.x < b.x;
简直了！！！

估计这个错误导致hash出现了问题・・・

finally，终于成功！！

太高兴了！！！

历时4天，将近25个小时，终于搞定了这个题・・・


网上解题报告：

题目倒是挺好玩的，但是……这一题涉及到的模拟过程比上一题的恶心程度以指数级增加……
需要模拟整个地图中宝石和飞行器的移动过程，然后还要消除掉相邻的相同的宝石。
把过程模拟好，也就向AC迈出了一大步。   
然后就是像做一般的隐式图搜索+哈希判重一样。

还有一个需要注意的地方，如果有多种方案，那么输出字典序最小的那个， 这样只需要在搜索时，方向按照字典序D，L，R, U的顺序搜索下去即可。

WA了一次，原因：
1.  大于18步的就不再考虑。
2. 每一个输入之后会多出一行无用的， 而且不一定是空行(这个还是看了discuss给的输入输出才知道的)，要把这一行读掉。

类型：  隐式图搜索+恶心模拟+哈希判重+bfs+dfs



