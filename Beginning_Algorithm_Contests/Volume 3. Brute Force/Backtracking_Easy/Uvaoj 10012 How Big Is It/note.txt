这题太阴险了・・・

用了uDebug的数据才发现・・・

有可能有一个特别小的圆在夹缝里，根本就不和相邻的两个圆相交！

发现我原来的思路不行，修改也很麻烦・・・

换个思路，每次找到每个圆的圆心位置！

哈哈，第二个思路完全正确！！AC了！！


哈哈，网上的东西跟我的第二个思路蛮像！

Internet 1:

这个题目WA得满痛苦的，一开始不知道为什么会WA，后来意识到原来是少考虑了两个相邻的圆半径差别很大的情况，
也就是说一个大圆下面可能可以放很多小圆，这时就又没头绪了。

后来看了别人的代码后，给了我很大的启发，原来可以在递归的过程中多引入一个表示当前放置的圆的圆心坐标的数组，来辅助计算。

我们以左下角为原点建立直角坐标系，暂且假设第一个圆是紧贴左下角放置的，然后用深搜枚举每个位置可能放的圆，
并计算放置这个圆的圆心坐标。计算的时候要依次假设当前圆和前面的某一个圆相切，并依此来计算当前圆的圆心坐标，
最后取所有结果的最大值，这样就得到了当前圆的放置时的实际的圆心坐标。

在放置完所有圆后，实际上可能存在某些圆的一部分是在y轴左半部分的，因而要求我们再遍历一遍所有放置好的圆，
找到所有圆最左边点的位置，并记录成矩形的左边界，或者把y轴更新到这个位置上，也就是说要把所有圆的圆心坐标加上计算所得的值，
这样就保证了x=0是矩形的左边的边界。之后就是计算右边的边界，同样，我们需要遍历一遍所有放置好的圆，找到所有圆最右边点的位置，
把这个位置作为矩形右边的边界即可。

Internet 2:

以为很简单，十分钟敲了一个全排列回溯，结果WA了。想了半天，才想到可能存在两个半径很大的圆相切，
中间夹着很多小的圆（这样单纯的全排列只判断相邻两圆的话就可能出现圆圆相交的情况），
这样就需要加一个圆心坐标和一个原点记录位置来做特判，令当前放置的圆与前面所有的圆相切求出最大的据原点的距离
（这样就可以保证排除圆圆相交的情况），再加上前面的距离即为放置这个新的圆的位置坐标。