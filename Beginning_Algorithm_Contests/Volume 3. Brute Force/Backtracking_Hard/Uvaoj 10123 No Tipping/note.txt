一开始的思路就是暴力枚举，一个一个的拿走，看看行不行。

但是会TLE！

稍微变形一下，变成一个一个往上加！
这样应该会化简不少情况！
(错了吧，应该一样啊！不知道那时候怎么想的・・・)

靠，仍然是TLE・・・

加了一个永远不可能tip的情况，还是TLE・・・

加了一个全在上面会不行的情况，仍然TLE・・・

现在的想法：

先从前，从后枚举8个，看谁少，从那个开始再往后枚举。
还没有试，不知道行不行・・・

再不行的话，我也不知道该怎么办了・・・

或者用空间换时间，把20C6的情况都存起来！

这样枚举只要到14！就行了・・・感觉比刚才的想法靠谱一些，但是实现起来感觉有些麻烦・・・

我的想法感觉都不是很靠谱・・・

唉，被lrj的思路限制了・・・根本没想到dp・・・
一共最多就2^20种情况，顺序根本不重要啊！
我怎么觉得在原来代码基础上加一个vis[2^20]就行了・・・

确实加上vis就行了・・・错的太SB了・・・根本没有往这方面想・・・


还是搜了一下网上的解题报告：


以下斜体部分是我第一次写的解题报告，但后来越来越觉得我实现的程序和我的想法并不怎么挂钩，于是就越发怀疑程序里那个剪枝的正确性了。

    再后来看了UVA的论坛之后，发现上面有人提到用记忆化搜索去解，我这时再一看N只有20，完全可以用状态压缩+记忆化搜索来做，只是当时没有想到，
其中一部分原因也是觉得LRJ放在了回溯这章里面，就压根没向着dp的方向去考虑，一直在想怎么剪枝去了，便也凑巧，
居然诞生了下面的我现在也不知道正确与否的回溯做法。以后千万不要局限于已知的这题的归类，换个思路也许就能海阔天空了。

    如果各位兄台谁有兴趣证明出了或者推翻了下面这个回溯的程序，还望能和小弟分享一下。当然，这个回溯程序在UVA上是能AC的，
而且跑得很快，但我后来总觉得这个程序的剪枝有问题。

    下面还是说一下dp的思路吧。由于N不大，2的20次方也就10^6左右，因此可以把所有木块的状态用2进制表示出来，
于是可以用f[i]表示是否可以达到木块的状态为i的这种状态。接下来我们既可以一个一个地向上放，也可以一个一个地向下拿，
只要看最后起始状态的f[st]是否为1即可。

    “首先，我们如果考虑怎么拿的话会比较麻烦，不如我们反过来考虑怎么放，如果每个时刻放的都能平衡，那么最后就能得出一个可行解。

    “但是如果直接回溯的话会超时，我们不妨慢慢来优化算法。

    “第一，最好把坐标先乘2化成整数，这样就避免了浮点数误差。

    “第二，我们在放的时候，一个贪心思路就是先把两个支点中间的木块放上，比较容易证明这样只会增加后续木板的稳定程度。

    “第三，我们应该把其余的木块按力矩大小降序排序，支点是离它最近的那个支点，先选力矩小的，这样一定程度上减少了木板弄翻的可能。

    “第四，上面的按力矩排序还带来了额外的好处，我们不妨用两个数组分别存左边和右边的待放的木块。
我们先考虑右边的，假设我们现在放了一个木块上去，结果发现后面无论怎么放木板都会右翻，
显然就不用再尝试这个木块右边的木块了，因为必然也会右翻。同样，对于左边的木块，假设我们现在放了一个木块上去，
结果发现后面无论怎么放木板都会左翻，显然就不用再尝试这个木块左边的木块了，因为必然也会左翻。
当然，如果后续可能左翻也可能右翻的话就要继续尝试剩余的木块。

    “考虑完上面几点之后就可以AC了。”


看看人家的剪枝，太厉害了・・・反正我是没想到・・・
其实我想到了一左一右放置，但是觉得它并不一定正确・・・
先排序是个好思路，然而先放置小的一定优吗？？

我觉得这个剪枝应该是不对的！！！应该有情况先放置中等的，使得其正好不tip。这样才能在另外一边放个重量较大的。

题解2：（跟第一个差不多）

题解：两种方法。
一、DFS剪枝+物理力矩+贪心二、状态压缩+记忆话搜索 ...
一：将放上去的砝码做一个逆变换，即初始化为杠杆上没有砝码，我们一个一个往上放，使其过程中不发生侧翻的情况。
侧翻的情况：当左边点的左端的力矩大于左边点的右端的力矩，会往左侧翻；当右边点的右端的力矩大于右边点的左端的力矩，会往右侧翻。
注意点：
1、处理时将坐标放大两倍，使1.5->3省略小数的处理。
2、处于-1.5~+1.5之间的先放，可以证明其不会影响杠杆的侧翻(剪枝)。
3、在此区间以外的分为两组，-L~-1.5为左组  +1.5~+L为右组，将两组按对应点力矩升序排列，放砝码时，若放最大的，
很可能会引起侧翻，所以尽可能维持平衡，从影响度最小的开始放，再放大的，这样到后面这些若干小的可以缓和另一侧大的砝码的侧翻影响效应，
从而尽可能维持平衡（若实在无法维持平衡   那就是impossible）。所以整个DFS过程可以贪心地去一边的砝码，
比如左边的按升序先放砝码，一直到左边再放一个就会引起侧翻后，再到右边的按升序放，用来抑制左边会侧翻的情况，
若左边还是侧翻继续往右边放，直到左边可以放为止，注意左右两组砝码都是有序的，这样省去了无序砝码的遍历查找时间(剪枝)。
一直维持这个过程，直到所有砝码都放上去，也没有出现侧翻的条件就ok；如果出现这样的情况，无论放左边还是放右边的都有侧翻情况发生，
那么这一种情况就是impossible的。（感觉这样的模式与快排的算法模式有点相似）

这个算法确实不对！！我的那种思想应该可以构造反例！！